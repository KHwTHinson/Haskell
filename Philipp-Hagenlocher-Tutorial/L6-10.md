# Haskell for Imperative Programmers #6 - Higher Order Functions & Anonymous Functions
## Take a function as an argument of a function
```haskell
app :: (a -> b) -> a -> b
app f x = f x

add1 :: Int -> Int
add1 x = x+1
app add1 1
 => 2
```

## Anonymous Functions
```haskell
(\<args> -> <expr>)
(\x -> x+1) 2 
 => 3

add1 = (\x -> x+1)
```

## Map
```haskell
map :: (a -> b) -> [a] -> [b]
map (\x -> x + 1) [1,2,3,4,5]
 => [2,3,4,5,6]
```

## Filter
```haskell
filter :: (a -> Bool) -> [a] -> [a]
filter (\x -> x > 2) [1,2,3,4,5]
 => [3,4,5]
```

# Haskell for Imperative Programmers #7 - Partial Function Application & Currying
## Currying
```haskell
add :: Int -> Int -> Int
add x y = x+y
add x = (\y -> x+y)
add = (\x -> (\y -> x+y))
```

## Partial Function Application
```haskell
add :: Int -> Int -> Int
add = (\x -> (\y -> x+y))

map :: (a -> b) -> [a] -> [b]
doubleList = map (\x -> 2*x)
```

# Haskell for Imperative Programmers #8 - Function Composition
## Composition
```haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
(f . g) equiv. to (\x -> f (g x))
```
e.g. 3 equivalent functions
```haskell
descSort = reverse . sort
descSort = (\x -> reverse (sort x))
descSort x = reverse (sort x)
```

```haskell
map2D :: (a -> b) -> [[a]] -> [[b]]
map2D = map . map
```

e.g. All below equivalent
```haskell
map2D = (\f1 xs -> map f1 xs) . (\f2 ys -> map f2 ys)
map2D = (\x -> (\f1 xs -> map f1 xs) ((\f2 ys -> map f2 ys) x))
map2D x = (\f1 xs -> map f1 xs) ((\fs ys -> map f2 ys) x)
map2D x = (\f1 xs -> map f1 xs) (\ys -> map x ys)
map2D x = (\xs -> map (\ys -> map x ys) xs)
map2D f xs = map (\ys -> map f ys) xs
```



