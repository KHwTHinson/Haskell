# Haskell for Imperative Programmers #6 - Higher Order Functions & Anonymous Functions
## Take a function as an argument of a function
```haskell
app :: (a -> b) -> a -> b
app f x = f x

add1 :: Int -> Int
add1 x = x+1
app add1 1
 => 2
```

## Anonymous Functions
```haskell
(\<args> -> <expr>)
(\x -> x+1) 2 
 => 3

add1 = (\x -> x+1)
```

## Map
```haskell
map :: (a -> b) -> [a] -> [b]
map (\x -> x + 1) [1,2,3,4,5]
 => [2,3,4,5,6]
```

## Filter
```haskell
filter :: (a -> Bool) -> [a] -> [a]
filter (\x -> x > 2) [1,2,3,4,5]
 => [3,4,5]
```

# Haskell for Imperative Programmers #7 - Partial Function Application & Currying
## Currying
```haskell
add :: Int -> Int -> Int
add x y = x+y
add x = (\y -> x+y)
add = (\x -> (\y -> x+y))
```

## Partial Function Application
```haskell
add :: Int -> Int -> Int
add = (\x -> (\y -> x+y))

map :: (a -> b) -> [a] -> [b]
doubleList = map (\x -> 2*x)
```

